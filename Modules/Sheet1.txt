VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "Sheet1"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Option Explicit



'************************************************************
'***************   Exposed Routines   ***********************
'************************************************************


Public Sub ApplyGroupings()
    On Error Resume Next
    Outline.ShowLevels RowLevels:=2
    Rows("1:400").Ungroup
    On Error GoTo 0
    
    Dim instanceGroup As Boolean
    Dim groupStart As Integer
    Dim cell As Range
    Dim rangeEnd As Integer
    rangeEnd = Range("C9").End(xlDown).Row
    
    'Begin keeping track of cells once we hit a certain color, when we switch color, group the rows that we tracked
    For Each cell In Range("C9:C" & rangeEnd)
        If (cell.Font.Color = RGB(128, 128, 128) And instanceGroup = False) Then
            instanceGroup = True
            groupStart = cell.Row
            If (cell.Row = rangeEnd) Then
                Rows(cell.Row).Group
            End If
        
        ElseIf (cell.Font.Color <> RGB(128, 128, 128) And instanceGroup = True) Then
            instanceGroup = False
            Rows(groupStart & ":" & cell.Row - 1).Group
            groupStart = 0
        ElseIf (instanceGroup = True And cell.Row = rangeEnd) Then
            Rows(groupStart & ":" & cell.Row - 1).Group
        Else
            'Next iteration
        End If
    Next cell
    
    Outline.ShowLevels RowLevels:=1

End Sub

Public Sub IgnoreErrors()
    'Characteristic values are inconsistently formatted, suppress the meaningless errors
    Dim workingRange As Range
    Set workingRange = Range("L9:L" & Range("L9").End(xlDown).Row)
    Dim charCell As Range
    
    For Each charCell In workingRange
        charCell.Errors.Item(xlInconsistentFormula).Ignore = True
        charCell.Errors.Item(xlUnlockedFormulaCells).Ignore = True
    Next charCell
End Sub




'************************************************************
'****************   Event Callbacks   ***********************
'************************************************************


'-----------------------------------------------------------------------------------------------------------------------------------------

'******************   Double Click   ************************


Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)
    If Target.Areas.Count = 1 Then
        If Target.column = GetCol("Attached Image(s) [Double Click]") And Target.Row > 3 Then
            SetAttachment Target:=Target
        ElseIf Target.column = GetCol("Characteristic Name") And Target.Font.Color = RGB(0, 176, 240) Then
            ExpandGroup Target:=Target
        End If
    End If
End Sub

Private Sub SetAttachment(Target As Range)
    Dim fso As FileSystemObject
    Dim path As String
    Set fso = New FileSystemObject
    path = Replace(ThisWorkbook.path, fso.GetFileName(ThisWorkbook.path), "Attachments")
10
    If Not (fso.FolderExists(path)) Then
        Dim result As Integer
        result = MsgBox("There doesn't seem to be an 'Attachments' directory for this project" & vbCrLf & "Would you like to create one?", vbYesNo)
        If result = vbYes Then
            fso.CreateFolder (path)
            GoTo 10
        Else
            Exit Sub
        End If
    End If
    
    'After we check to see if the "Attachments" folder exists
    Target.Value = ""
    
    With Application.FileDialog(msoFileDialogFilePicker)
        .InitialFileName = path
        .Title = "Select Feature Attachment(s)"
        .Show
        Dim i As Integer
        For i = 1 To .SelectedItems.Count
            Dim arr() As String
            arr = Split(.SelectedItems.Item(i), "\")
            Target.Value = Target.Value & arr(UBound(arr))
            'If there's more than one file, then we need to delimit it by a character that can't appear in the file name
            If i <> .SelectedItems.Count Then
                Target.Value = Target.Value & "|"
            End If
        Next i
    End With
    Target.offset(1, 0).Select

End Sub

Private Sub ExpandGroup(Target As Range)
    'Show/Hide children of multiple instance features when user double-clicks
    Dim child As Range
    Set child = Target.offset(1, 0)
    Rows(child.Row).ShowDetail = Rows(child.Row).EntireRow.Hidden
    child.Activate
    
End Sub


'******************   On Change   ************************


Private Sub Worksheet_Change(ByVal Target As Range)
    
    If Target.Areas.Count = 1 Then
        Dim subCell As Range
        For Each subCell In Target
            Dim immutable As Range
            Dim inter As Range
            Set immutable = Rows(DataSources.VISUALS)
            On Error GoTo 20
            Set inter = Application.Intersect(immutable, subCell)
            
            'if it intercepts our "Immutable Visuals Range", dont do anything
            If Not (inter Is Nothing) Then Exit Sub
            
            On Error GoTo errmsg
            'change to Inspection Type (this should only trigger if the user changed the value manually)
            If subCell.column = GetCol("Inspection Type") Then
                Application.EnableEvents = False 'prevent recursive looping
                If subCell.Value = "" Then
                    subCell.Font.Color = RGB(0, 0, 0) 'revert back to black
                Else
                    subCell.Font.Color = RGB(112, 48, 160) 'set purple to designate custom value
                End If
            'change to Inspection Method
            ElseIf subCell.column = GetCol("Inspection Method") Then
                On Error GoTo 20
                Application.EnableEvents = False 'prevent recursive looping
                
                Call SetInspMethodValidation(cell:=subCell) 'Reset the validation in case of copy/paste
                
                If subCell.Value = "" Then
                    subCell.offset(0, -7).Value = "" 'set Insp Type to nothing
                    subCell.offset(0, 2).Value = "" 'set Pins/Gauges to nothing
                Else
                    Dim inspType As String
                    
                    inspType = AssignInspType(subCell.Value) 'is Attribute/Variable type of Inspection Method?
                    
                    Dim minIndex As Integer
                    Dim maxIndex As Integer
                    minIndex = InStr(subCell.offset(0, -2).Value, "MIN")
                    maxIndex = InStr(subCell.offset(0, -2).Value, "MAX")
                    If inspType = "Variable" And (minIndex > 0 Or maxIndex > 0) Then
                        If (InStr(subCell.offset(0, -2).Value, "MINOR") = 0) Then
                            If Not (subCell.offset(0, -9).Font.Color = RGB(112, 48, 160)) Then 'if the text is purple already, we should not call this
                            
                                Dim result As Integer
                                result = MsgBox("When using an Inpsection Method of a Variable Inspection Type to check a MAX/MIN dimension" _
                                                & " it is STRONGLY recommended that you set a Mfg. Tolerance." & vbCrLf & vbCrLf _
                                                & "Set Mfg Tolernace?", vbYesNoCancel, "Variable Insp. on a Min/Max Dimension")
                                If result = vbCancel Then
                                    subCell.Value = ""
                                    GoTo 10
                                ElseIf result = vbYes Then
                                    Call LoadMfgTol(inspMethodCell:=subCell, minIndex:=minIndex, maxIndex:=maxIndex)
                                Else
                                    'User doesnt care, do nothing
                                End If
                            End If
                        End If
                    End If
                    
                    subCell.offset(0, -7).Value = inspType 'set Attribute/Variable
                    subCell.offset(0, 2).Value = SetGaugePinData(methodCell:=subCell) 'Set Gauge Pin data if applicable
                    
                End If
                subCell.offset(0, -7).Font.Color = RGB(0, 0, 0)
            ElseIf Target.column = GetCol("Ltol") Or Target.column = GetCol("Nominal") Or Target.column = GetCol("Utol") Then
                'TODO: if these cells were manually changed, we should set the color and maybe even prompt the user to add a mfg tol note
            ElseIf Target.column >= GetCol("2 DIGIT Primary Tool") And Target.column <= GetCol("Secondary Head") Then
                On Error GoTo 20
                Application.EnableEvents = False
                Target.Value = UCase(Target.Value)
                    'TODO: check that this is not in the immutable rnage
                    'TODO: check that this is not an empty string
                
                If Target.column = GetCol("Primary Control") Or Target.column = GetCol("Secondary Control") Then
                    'TODO: if the user manually entered a value for the controls, we should hand-validate the entry
                    'TODO: likely should turn off events before setting this value
                    Call ValidateControl(controlCell:=Target)
                    
                ElseIf Target.column = GetCol("Primary Head") Or Target.column = GetCol("Secondary Head") Then
                    Call ValidateHead(controlCell:=Target)
                End If
                'If we made a chang to one of our TOOL Controls, we should re-evaluate the TOOL AXIS OFFSET
                Call OffsetCommentFormat(offsetRange:=Target.offset(0, GetCol("TOOL AXIS OFFSET") - Target.column))
                
                'Somebody changed the control, either manually typed or perhaps set with a drop-down choice
            ElseIf Target.column = GetCol("Comments") Then
                Call SetCommentsValidation(cell:=subCell) 'Reset the validation in case of copy/paste
            End If
        Next subCell
    End If
20
    Application.EnableEvents = True
10
    Exit Sub
errmsg:
    MsgBox (Err.Number & vbCrLf & Err.Description)
    GoTo 20
End Sub


'************************************************************
'***************   Support Functions   **********************
'************************************************************

'***************   Inspection Methods   *********************

Private Function AssignInspType(Method As String) As String
    Dim valWB As Workbook
    Dim valSheet As Worksheet
    On Error GoTo 10
    Set valWB = Workbooks("RoutineMapDataValidations.xlsm")
    Set valSheet = valWB.Worksheets("Data Validations")
    
    Dim workingRange As Range
    Set workingRange = valSheet.Range("$E$2:$F$" & valSheet.Range("F2").End(xlDown).Row)
    Dim inspType As Variant
    inspType = Application.WorksheetFunction.VLookup(Method, workingRange, 2, False)
    AssignInspType = inspType
    
10
End Function

Private Function SetGaugePinData(methodCell As Range) As String

    'Gauge Pins method called out
    If InStr(methodCell.Value, "Gauge Pins") > 0 Then
        Dim ballNum As String
        Dim iexWS As Worksheet
        ballNum = Split(methodCell.offset(0, -3).Value, "_")(0) 'error handling here in event that it isnt a balloon number [(iv)]
        
        Set iexWS = Worksheets("IEX-Data")
        Dim workingRange As Range
        Set workingRange = iexWS.Range("A2:G" & iexWS.Range("G2").End(xlDown).Row)
        
        'Error handling in the event we can't find the balloon
        Dim units As String
        units = Application.WorksheetFunction.VLookup(ballNum, workingRange, 7, False)
        Dim featureType As String
        featureType = Application.WorksheetFunction.VLookup(ballNum, workingRange, 5, False)
        
        Dim trunc As Double
        Dim nom As Double
        Dim conv As Double
        Dim tol As Double
        Dim lTol As Double
        Dim uTol As Double
        Dim setPins As Boolean
        Dim userInput As String
        
        'What are the dimension units
        Select Case units
        Case "deg"
            GoTo 80
        Case "mm" 'only use Inch pins, so we need to convert
            conv = 25.4
        Case "in"
            conv = 1
        Case Else
            MsgBox ("Dimension does not have a recognized unit type")
            GoTo 80
        End Select
        
        'What is the tolerance range
        tol = CDbl(methodCell.offset(0, 4).Value) / conv
        nom = ((CDbl(methodCell.offset(0, -8).Value) + CDbl(methodCell.offset(0, -10).Value)) / conv) / 2
        
        
        'GDT features have a 'target' value set, but nothing for low/high values. Therefore
        'we should be handling the nominal differently by converting just that target value
        If featureType = "Geometric Tolerance" Then
            nom = CDbl(methodCell.offset(0, -9).Value) / conv
        End If
            
        If methodCell.Value = "Gauge Pins  Go" Then
            If featureType = "Geometric Tolerance" Then GoTo 80
            lTol = CDbl(methodCell.offset(0, -10).Value) / conv
            SetGaugePinData = "(" & Format(lTol, ".0000") & " FULL)"
            
        ElseIf methodCell.Value = "Gauge Pins  NoGo" Then
            If featureType = "Geometric Tolerance" Then GoTo 80
            uTol = CDbl(methodCell.offset(0, -8).Value) / conv
            SetGaugePinData = "(" & Format(uTol, ".0000") & " FULL)"
            
        ElseIf methodCell.Value = "Gauge Pins  Var.Best.Fit." Then
            uTol = nom + (tol / 2)
            lTol = nom - (tol / 2)
            userInput = InputBox("Enter gauge pin size to step by" & vbCrLf & "(Must be in Inches)", , ".0002")
            
            If featureType = "Geometric Tolerance" Then
                SetGaugePinData = "(.0000" & " through " & Format(nom, ".0000") & ")" & " by " & userInput
            Else
                SetGaugePinData = "(" & Format(lTol, ".0000") & " through " & Format(uTol, ".0000") & ")" & " by " & userInput
            End If
            
            
        ElseIf methodCell.Value = "Gauge Pins  Go/NoGo" Then
            If featureType = "Geometric Tolerance" Then GoTo FullFMT
            
        'If we donthave a MIN/MAX keyword present
            If Not (InStr(methodCell.offset(0, -2), "MAX") > 0) And Not (InStr(methodCell.offset(0, -2), "MIN") > 0) Then
                Select Case tol
                Case Is >= 0.002 'Needs 50% Truncation
                    trunc = 0.25
                    setPins = True
                Case Is > 0.001  'Needs 25% Truncation
                    trunc = 0.125
                    setPins = True
                Case Else        'No Truncation
                    setPins = False
                End Select
                
                Dim setString As String
                Dim fullString As String
                
                If setPins = True Then
                    setString = "(" & Format(nom - (tol * trunc), ".0000") & " " & Format(nom + (tol * trunc), ".0000")
                    setString = setString & " SET)"
                End If
                
                fullString = "(" & Format(nom - (tol * 0.5), ".0000") & " " & Format(nom + (tol * 0.5), ".0000")
                fullString = fullString & " FULL)"
            Else
                'otherwise it is a MIN/MAX/GDT, only use a FULL here
                'we have to switch to using the nominal cell value
                nom = CDbl(methodCell.offset(0, -9).Value) / conv
FullFMT:
                fullString = "(" & Format(nom, ".0000") & " FULL)"
            End If
            
            Dim resultString As String
            If setPins = True Then resultString = setString & " "
            SetGaugePinData = resultString & fullString
        End If
           
    'Thread Guage(s) is chosen
    ElseIf InStr(methodCell.Value, "Thread") > 0 And InStr(methodCell.Value, "Gauge") > 0 Then
        'if we are calling out a thread gauge to be used, then set this value as equal to the description most likely
        SetGaugePinData = methodCell.offset(0, -2).Value
        
    'Most Likely, Functional Gauge is chosen
    ElseIf InStr(methodCell.Value, "Gauge") > 0 Then
        Dim displayMsg As String
        Dim collectedGauges As String
        displayMsg = "Add a JPMC Gauge Number?"
        
        Do
            userInput = InputBox(displayMsg, "Enter Gauge ID")
            userInput = Trim(userInput)
            displayMsg = "Add another JPMC Gauge Number?"
            If userInput <> vbNullString And collectedGauges <> vbNullString Then
                collectedGauges = collectedGauges & ", "
            End If
            
            collectedGauges = collectedGauges & userInput
        
        Loop While userInput <> vbNullString
        
        If collectedGauges = vbNullString Then collectedGauges = "????"
        SetGaugePinData = "(JPMC " & collectedGauges & ")"
    Else
80
        SetGaugePinData = "NA"
    End If
End Function


'***************   Mfg Tolerances   *********************

'Display the mfg tol Userform
Private Sub LoadMfgTol(inspMethodCell As Range, minIndex As Integer, maxIndex As Integer)
    Load CreateMfgTolerance
    If maxIndex > 0 Then 'If this is a MAX dimension, disable the Utol Input field
        CreateMfgTolerance.UTolTextBox = inspMethodCell.offset(0, -8).Value
        CreateMfgTolerance.UTolTextBox.Enabled = False
    Else 'If this is a MIN dimension, disable the Ltol Input field
        CreateMfgTolerance.LTolTextBox = inspMethodCell.offset(0, -10).Value
        CreateMfgTolerance.LTolTextBox.Enabled = False
    End If
    CreateMfgTolerance.Tag = inspMethodCell.offset(0, -11).Address
    CreateMfgTolerance.Show

End Sub

'Called by mfg Tol userform
'TODO: maybe this method can be called from a ribbon function to set a new mfg tolerance
Sub SetMfgTol(charAddress As String, inputs() As Variant)
    Dim charRange As Range
    Set charRange = Range(charAddress) 'Address of e.g. 0_008_01
    Dim i As Integer
    
    For i = 1 To 3
        Dim offsetRange As Range
        Set offsetRange = charRange.offset(0, i)
        
        'If we want to skip overriding of already mfg tol values
        'If offsetRange.Font.Color = RGB(112, 48, 160) Then GoTo continue
        
        If offsetRange.Value = "" Then offsetRange.Value = 0
        
        If (offsetRange.CommentThreaded Is Nothing) Then
            offsetRange.AddCommentThreaded ("Original Value: " & offsetRange.Value)
        Else
            offsetRange.CommentThreaded.AddReply ("Prev Value: " & offsetRange.Value)
        End If
        offsetRange.Value = inputs(i - 1)
        offsetRange.Font.Color = RGB(112, 48, 160)
        
continue:
    Next i
    
    Dim commentRange As Range
    Set commentRange = charRange.offset(0, 10)
    If Not (InStr(commentRange.Value, "Mfg. Tol") > 0) Then
        commentRange.Value = commentRange.Value & "Mfg. Tol."
    End If
    
End Sub

'***************   Tool Axis Offset   *********************



'Values in the given cell should either be from the selectable drop-down list or (#XXX or DXXX) format
Sub ValidateControl(controlCell As Range)
    Dim cellInput As String
    Dim validInput As Boolean
    Dim i As Integer
    Application.EnableEvents = False
    On Error GoTo 10
    
'    controlCell.Value = UCase(controlCell.Value)
    If Len(controlCell.Value = 3) And IsNumeric(controlCell.Value) Then
        controlCell.Value = "#" & controlCell.Value
    End If
    
    For i = 1 To Len(controlCell.Value)
        If IsNumeric(Mid(controlCell.Value, i, 1)) Then
            cellInput = cellInput & "?"
        Else
            cellInput = cellInput & Mid(controlCell.Value, i, 1)
        End If
    Next i
    
    Call OpenDataValidations
    validInput = valWB.ControlIsInValidationRange(cellInput)
    
    If Not validInput Then
        controlCell.Value = ""
    End If

10
    Application.EnableEvents = True
        
End Sub

Sub ValidateHead(controlCell As Range)
    Dim headInput As String
    headInput = controlCell.Value
    Call OpenDataValidations
    
    If IsNumeric(headInput) Then
        If CInt(headInput) <= 3 And CInt(headInput) >= 1 Then
            controlCell.Value = "HD" & headInput
        Else
            GoTo 10
        End If
    ElseIf valWB.HeadIsInValidationRange(headInput) Then
        
    Else
10
        controlCell.Value = ""
    End If

End Sub

'Recalculate the 'Tool Axis Offset' Field
'We should also evaluate that both sets of columns are not just duplicates of each other
Private Sub OffsetCommentFormat(offsetRange As Range) 'TODO: add parameter here to take an input field

    offsetRange.Value = ""
    
    Dim expandedFormat As Boolean
    Dim Tpr As String
    Dim Tse As String
    Dim Cpr As String
    Dim Cse As String
    Dim Hpr As String
    Dim Hse As String
    
    Tpr = ParseToolValue(Trim(offsetRange.offset(0, 2).Value))
    Tse = ParseToolValue(Trim(offsetRange.offset(0, 5).Value))
    Cpr = offsetRange.offset(0, 3).Value
    Cse = offsetRange.offset(0, 6).Value
    Hpr = " " & offsetRange.offset(0, 4).Value
    Hse = " " & offsetRange.offset(0, 7).Value
    
    'If data is missing from the primary columns, then dont do anything
    If Tpr = vbNullString Or Cpr = vbNullString Or Trim(Hpr) = vbNullString Then
        Exit Sub
    End If
    'If all of the values in the second set are nothing, then that is fin
    If Tse = vbNullString And Cse = vbNullString And Trim(Hse) = vbNullString Then
    
    'If all of the values in the second set have something filled in then that is fine too
    ElseIf Tse <> vbNullString And Cse <> vbNullString And Trim(Hse) <> vbNullString Then
    
    Else 'Otherwise we have a partial fillout, the result should remain ""
        Exit Sub
    End If
    
    Tpr = "T" & Format(Tpr, "00")
    If Tse <> vbNullString Then Tse = "T" & Format(Tse, "00")
    
    
    'We should also just escape I guess if both sets of columns are the same
    
    
    'if the secondary column is incomplete then we should set all the secondary stuff to ""
    If Tse = vbNullString Or Cse = vbNullString Or Hse = vbNullString Then
        'if even one value is missing, set them all to nothing
        Tse = vbNullString
        Cse = vbNullString
        Hse = vbNullString
    
    ElseIf StrComp(Hpr, Hse, vbTextCompare) = 0 And StrComp(Tpr, Tse, vbTextCompare) = 0 Then
        Tse = ""
        Hpr = ""
    ElseIf StrComp(Hpr, Hse, vbTextCompare) = 0 Then
        Hpr = " "
    ElseIf Trim(Hse) <> "" Then
        expandedFormat = True
    End If
    
    If expandedFormat = False Then
        offsetRange.Value = (Tpr & GetControlDelimiter(Cpr) & Cpr & Hpr & Tse & GetControlDelimiter(Cse) & Cse & Hse)
    Else
        offsetRange.Value = (Tpr & GetControlDelimiter(Cpr) & Cpr & Hpr & " & " & Tse & GetControlDelimiter(Cse) & Cse & Hse)
    End If

End Sub


Private Function GetControlDelimiter(control As String) As String
    Select Case control
        Case "TOOL"
            GetControlDelimiter = " "
        Case "PROG"
            GetControlDelimiter = " "
        Case vbNullString
            GetControlDelimiter = ""
        Case Else
            GetControlDelimiter = ","
    End Select

End Function

Private Function ParseToolValue(tool As String) As String
    If Left(tool, 1) = "T" And Len(tool) > 1 Then
        If Right(tool, Len(tool) - 1) Then
            ParseToolValue = Right(tool, Len(tool) - 1)
        Else
            GoTo 10
        End If
    ElseIf IsNumeric(tool) Then
        ParseToolValue = tool
    Else
10
        'We can't parse this, doesn't makes sense
    End If

End Function














'Return column # of the header
Private Function GetCol(colName As String) As Integer
    Dim colRange As Range
    Set colRange = Range("A3:Y3")
'    Dim retRange As Range
'    Set retRange = colRange.Find(What:=colName, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
'    GetCol = retRange.column
    On Error Resume Next
    GetCol = Application.WorksheetFunction.Match(colName, colRange, 0)
    If Err.Number <> 0 Then
        GetCol = 0
    End If
    On Error GoTo 0
End Function
















