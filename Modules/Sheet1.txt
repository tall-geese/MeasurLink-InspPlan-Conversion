VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "Sheet1"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Option Explicit
'*************************************************************
'*************************************************************
'*                  PartLib Table
'*
'*************************************************************
'*************************************************************


'************************************************************
'***************   Exposed Routines   ***********************
'************************************************************


Public Sub ApplyGroupings()
    On Error Resume Next
    Outline.ShowLevels RowLevels:=2
    Rows("1:400").Ungroup
    On Error GoTo 0
    
    Dim instanceGroup As Boolean
    Dim groupStart As Integer
    Dim cell As Range
    Dim rangeEnd As Integer
    rangeEnd = Range("C9").End(xlDown).Row
    
    'Begin keeping track of cells once we hit a certain color, when we switch color, group the rows that we tracked
    For Each cell In Range("C9:C" & rangeEnd)
        If (cell.Font.color = RGB(128, 128, 128) And instanceGroup = False) Then
            instanceGroup = True
            groupStart = cell.Row
            If (cell.Row = rangeEnd) Then
                Rows(cell.Row).Group
            End If
        
        ElseIf (cell.Font.color <> RGB(128, 128, 128) And instanceGroup = True) Then
            instanceGroup = False
            Rows(groupStart & ":" & cell.Row - 1).Group
            groupStart = 0
        ElseIf (instanceGroup = True And cell.Row = rangeEnd) Then
            Rows(groupStart & ":" & cell.Row - 1).Group
        Else
            'Next iteration
        End If
    Next cell
    
    Outline.ShowLevels RowLevels:=1

End Sub

Public Sub IgnoreErrors()
    'Characteristic values are inconsistently formatted, suppress the meaningless errors
    Dim workingRange As Range
    Set workingRange = Range("L9:L" & Range("L9").End(xlDown).Row)
    Dim charCell As Range
    
    For Each charCell In workingRange
        charCell.Errors.Item(xlInconsistentFormula).Ignore = True
        charCell.Errors.Item(xlUnlockedFormulaCells).Ignore = True
    Next charCell
End Sub

Public Function IsInImmutableRange(targetCell As Range) As Boolean
    'We don't want to apply certain changes to the top 5 rows of visual criteria
    Dim immutable As Range
    Dim intersection As Range
    Set immutable = Rows(DataSources.VISUALS)
    On Error GoTo 10
    Set intersection = Application.Intersect(immutable, targetCell)
    If Not intersection Is Nothing Then
        IsInImmutableRange = True
    End If
    
    Exit Function
10
    Err.Raise vbObjectError + 1000, Description:="Problem with verifying immutable range" & vbCrLf & Err.Description

End Function


'Return column # of the header
Public Function GetCol(colName As String) As Integer
    Dim colRange As Range
    Set colRange = Range("A3:BZ3")
'    Dim retRange As Range
'    Set retRange = colRange.Find(What:=colName, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
'    GetCol = retRange.column
    On Error Resume Next
    GetCol = Application.WorksheetFunction.Match(colName, colRange, 0)
    If Err.Number <> 0 Then
        GetCol = 0
    End If
    On Error GoTo 0
End Function

'Set a variable formula, called by our ConditionalFeature form
Public Sub ApplyFormula(targetCol As String, Optional limit As Variant, Optional varCol As Variant)
    On Error GoTo formErr
    
    Dim colNum As Integer
    
    Select Case targetCol
    Case "Variable/Attribute"
        colNum = GetCol("Inspection Type")
    Case "Characteristic Desc."
        colNum = GetCol("Characteristic Description")
    Case "Comments"
        colNum = GetCol("COMMENTS")
    Case "Inspection Method"
        colNum = GetCol("INSPECTION METHOD")
    Case "Frequency"
        colNum = GetCol("IN-PROCESS, INSPECTION FREQUENCY")
    Case "Pins / Gauges"
        colNum = GetCol("PINS / GAUGES")
    Case "Tool Axis Offset"
        colNum = GetCol("TOOL AXIS OFFSET")
    Case "Attached Images"
        colNum = GetCol("Attached Image(s) [Double Click]")
    Case "Lower"
        colNum = GetCol("Ltol")
    Case "Nominal"
        colNum = GetCol("Nominal")
    Case "Upper"
        colNum = GetCol("Utol")
    Case Else
    
    End Select
    
    Application.EnableEvents = False
    
    Dim targetCell As Range
    Set targetCell = Cells(ActiveCell.Row, colNum)
    targetCell.Value = ""
    Dim prefix As String
    
    If targetCol = "Lower" Then
        If IsMissing(varCol) Then
            'form = the nom cell - the hard limit
            targetCell.formula = "=$E" & ActiveCell.Row & " - " & limit
        Else
            'for = the nom cell - the vlookup
            prefix = "$E" & ActiveCell.Row & " - "
            GoTo 10
        End If
    ElseIf targetCol = "Upper" Then
        If IsMissing(varCol) Then
            'form = the nom cell + the hard limit
            targetCell.formula = "=$E" & ActiveCell.Row & " + " & limit
        Else
            'for = the nom cell + the vlookup
            prefix = "$E" & ActiveCell.Row & " + "
            GoTo 10
        End If
    ElseIf targetCol = "Nominal" And IsMissing(varCol) Then
        targetCell.Value = limit
    Else
    
10
        Dim formulaCol As Integer
        formulaCol = Worksheets("Variables").GetCol(varCol)
        targetCell.NumberFormat = "General"
        targetCell.formula = "=" & prefix & "VLOOKUP('START HERE'!$C$8,Variables!$A$2:$AZ$500," & formulaCol & ",FALSE)"
    End If
    
    Rows(ActiveCell.Row).Interior.ColorIndex = 33
20
    Application.EnableEvents = True
    
    Exit Sub
    
formErr:
    MsgBox ("Error when setting formula for:" & targetCol)
    GoTo 20
    
End Sub

'apply hiding based on certain part numbers or variable lookups, called by HideFeatureCond userform,
Public Sub SetHiding(features As String, hideForm As String)
    Dim cellAdd() As String
    
    If InStr(features, ",") > 0 Then
        cellAdd = Split(features, ",")
    Else
        ReDim Preserve cellAdd(0)
        cellAdd(0) = features
    End If

    Dim tolerRows As Range
    Dim toolRows As Range
    Set tolerRows = Range("H1:K1").EntireColumn
    Set toolRows = Range("R1:X1").EntireColumn
    
    Application.EnableEvents = False

    Dim i As Integer
    Dim j As Integer
    For i = 0 To UBound(cellAdd)
        Dim charCell As Range
        Set charCell = Range(cellAdd(i))
        For j = 0 To 22
            Dim tempCell As Range
            Set tempCell = charCell.offset(0, j)
            If (Application.Intersect(tolerRows, tempCell) Is Nothing) And (Application.Intersect(toolRows, tempCell) Is Nothing) Then
                tempCell.NumberFormat = "General"
                If InStr(tempCell.formula, "=") > 0 Then 'Don't break formulas, just make their result the ELSE condition
                    If InStr(tempCell.formula, "IF(") > 0 Then GoTo 10  'if the formula already has the IF conditoin set on it then we don't
                                                                            'want to change anything
                    tempCell.formula = hideForm & Replace(tempCell.formula, "=", "") & ")"
                Else
                    tempCell.formula = hideForm & Chr(34) & tempCell.Value & Chr(34) & ")"
                End If
            End If
10
        Next j
    Next i
20
    Application.EnableEvents = True
    Exit Sub
    
hideErr:
    MsgBox "Could not set the formula" & vbCrLf & hideForm & vbCrLf & "For features:" & vbCrLf & features, vbCritical
    GoTo 20
End Sub

'Called by RibbonCommands.PivotFeature
Public Function GetCharOrFamily(charCell As Range) As Range
    'If a cell is a parent and theres a parent below it, do nothing
    If charCell.EntireRow.OutlineLevel = 1 And charCell.offset(1, 0).EntireRow.OutlineLevel = 1 Then
        Set GetCharOrFamily = charCell
        Exit Function
    End If
    
    'If we're in a child feature, we want to propogate up until we find the parent
    If charCell.EntireRow.OutlineLevel = 2 Then
        Do
            Set charCell = charCell.offset(-1, 0)
        Loop While charCell.EntireRow.OutlineLevel = 2
    End If
    
    'Extend our range down until we have the parent and all child cells
    Dim ogRange As Range
    Set ogRange = Range(charCell.Address)
    Do
        Set charCell = Application.Union(charCell, charCell.offset(1, 0))
    Loop While ogRange.offset(charCell.Count, 0).EntireRow.OutlineLevel = 2

    'Then pass them back
    Set GetCharOrFamily = charCell


End Function

'Called by CreateRoutinesForm
Public Sub SetRoutines(routineArr() As Variant, selectedColor As Long, opTag As String, machOp As String)
    On Error GoTo rtSetErr

    If (Not routineArr) = -1 Then Exit Sub
    'If machOp Is missing Then machOp = 1  'TODO: replace with the logic that keeps track of added machining ops
    'TODO: there needs to be something that captures the name of the operation set like Receiving, Milling, etc.
    
    Dim nextCol As Range
    Set nextCol = Range(Range("C3").End(xlToRight).Address).offset(0, 1)
    
    Dim sequence As String
    If opTag = "SWISS" Or opTag = "MILL" Then
        If CInt(machOp) > 1 Then
            sequence = machOp
        End If
    End If
    
    Dim i As Integer
    Dim suffix As String
    If opTag = "MILL" Then suffix = "_MILL"
    
    Application.EnableEvents = False
    
    Call AppendOperationNames(opTag & sequence)
    
    For i = 0 To UBound(routineArr)
        nextCol.Value = routineArr(i) & sequence & suffix
        nextCol.offset(-1, 0).Value = "QE"
        Range(nextCol.offset(-1, 0).Address & ":" & Replace(nextCol.offset(-1, 0).Address, "2", "400")).Interior.color = selectedColor
        
        Set nextCol = nextCol.offset(0, 1)
    Next i
    
    
20
    Application.EnableEvents = True
    Exit Sub
    
rtSetErr:
    MsgBox "Encountered a problem when setting Routines", vbCritical
    On Error GoTo 0
    GoTo 20
End Sub


'Called by SetRoutines
Public Sub AppendOperationNames(opName As String)
    Dim charRange As Range
    Dim i As Integer
    On Error GoTo 10
    Cells(9, 3).Activate
    Set charRange = Application.InputBox("Select Characteristics the OP(s) are Applicable to", "Select Characteristics", Type:=8)
    If charRange Is Nothing Then Exit Sub
    If charRange.Worksheet.Name <> "PartLib Table" Then GoTo 10
    
    Dim addys() As String
    If InStr(charRange.Address, ",") > 0 Then 'If multiple areas are chosen, split them up
        addys = Split(charRange.Address, ",")
    Else
        ReDim Preserve addys(0) 'Otherwise just set the one area
        addys(0) = charRange.Address
    End If
    
    'Address validation
    For i = 0 To UBound(addys)
        If InStr(addys(i), ":") > 0 Then
            If Len(addys(i)) - Len(Replace(addys(i), "$C$", "")) <> 6 Then GoTo 10 'If $C$X:$C$X, not all in the C Column
        Else
            If Len(addys(i)) - Len(Replace(addys(i), "$C$", "")) <> 3 Then GoTo 10 'IF $C$6, not in the C column
        End If
    Next i
    
    'iterate through the cells and set their Operation values
    For i = 0 To UBound(addys)
        Dim tempRange As Range
        Set tempRange = Range(addys(i))
        Dim subCell As Range
        For Each subCell In tempRange
            If subCell.Value <> vbNullString Then
                subCell.offset(0, 23).Value = opName
            End If
        Next subCell
    Next i
    
    Call Worksheets("MachineOps").InsertNewOp(opName)
    
    
    Exit Sub

10
    'TODO: might want to raise an error here instead, to propogate to the calling sub in case we don't want to do anything
        'In the result of an error
    MsgBox "You did not choose a valid Characteristic Name Range" & vbCrLf & "Choose ONLY values from Column C", vbCritical
    Err.Raise Number:=vbObjectError + 1000, Description:="Incorrect Range"
    
End Sub

'Called by RibbonCommands.ExportQIF
Public Function CollectFeaturesForExport(routineName As String) As Variant()
    'TODO: this maybe has to be passed a Routine Name, so we can cross-examine that the
    'characteristic that we come across does in fact have occur in that routine
    Me.Outline.ShowLevels RowLevels:=2
    Dim workingRng As Range
    Set workingRng = Range("A4:A" & Range("A4").End(xlDown).Row)
    Dim featureArr() As Variant
    Dim rtCol As Integer
    rtCol = GetCol(routineName)
    Dim indexCell As Range
    
    For Each indexCell In workingRng
        If indexCell.offset(0, 2).Value <> "" Then 'Passover Empty Characteristics, they could be conditionally hidden
            If indexCell.offset(0, 6).Value = "" Then   'Characteristic set, but InspectionType NOT set
                MsgBox ("Error here: " & indexCell.offset(0, 2).Value & vbCrLf & "No Inspection Type (Variable/Attribute) was set")
                GoTo 10
            ElseIf indexCell.offset(0, rtCol - indexCell.column).Value = "" Then 'If there is no X or O or anything for the routine, skip this
                GoTo cont
            Else
                If (Not featureArr) = -1 Then
                    ReDim Preserve featureArr(0 To 4, 1 To 1)
                Else
                    ReDim Preserve featureArr(0 To 4, 1 To UBound(featureArr, 2) + 1)
                End If
                
                Dim ulim As Integer
                ulim = UBound(featureArr, 2)
                featureArr(0, ulim) = indexCell.offset(0, 2).Value '0_001_00
                featureArr(1, ulim) = indexCell.offset(0, 6).Value 'Attribute / Varible
                
                If featureArr(1, ulim) = "Variable" Then
                    'TODO: check for discrepencies in setting the low/nom/high lim
                    'Prob just need to check if the nom is there or not
                    If indexCell.offset(0, 4).Value = "" Then
                        MsgBox ("Error here: " & indexCell.offset(0, 2).Value & vbCrLf & "No Nominal was set")
                        GoTo 10
                    Else
                        featureArr(2, ulim) = indexCell.offset(0, 3).Value 'LowLim
                        featureArr(3, ulim) = indexCell.offset(0, 4).Value 'Nominal
                        featureArr(4, ulim) = indexCell.offset(0, 5).Value 'HighLim
                    End If
                    
                ElseIf featureArr(1, ulim) = "Attribute" Then
                    featureArr(2, ulim) = "" 'Set nothing for Low/Nom/High Lims
                    featureArr(3, ulim) = ""
                    featureArr(4, ulim) = ""
                End If
            End If
        End If
cont:
    Next indexCell
    
    CollectFeaturesForExport = featureArr
    Exit Function
      
ftReadErr:
    MsgBox "Encountered an issue with reading a feature" & vbCrLf & "index: " & indexCell.offset(0, 2).Value, vbCritical
10
    Err.Raise Number:=vbObjectError + 1100, Description:="Missing Information"

End Function

'Called by RibbonComands.ExportQIF
Public Function GetRoutineListing() As String()
    Dim rtRange As Range
    Dim routineArr() As String
    Set rtRange = Range("AA3:BZ3")
    Dim subCell As Range
    
    For Each subCell In rtRange
        If subCell.Value <> "" Then
            If (Not routineArr) = -1 Then
                ReDim Preserve routineArr(0)
                routineArr(0) = subCell.Value
            Else
                ReDim Preserve routineArr(UBound(routineArr) + 1)
                routineArr(UBound(routineArr)) = subCell.Value
            End If
        End If
    Next subCell
    
    GetRoutineListing = routineArr

End Function

'TODO: temp placeholder
Public Sub DeleteRoutine(routineName As String)
    Dim colNum As Integer
    Dim routineRng As Range
    colNum = GetCol(routineName)
    Set routineRng = Cells(1, colNum).EntireColumn
    
    Application.EnableEvents = False
    routineRng.Delete
    Application.EnableEvents = True
End Sub





'************************************************************
'****************   Event Callbacks   ***********************
'************************************************************


'-----------------------------------------------------------------------------------------------------------------------------------------

'******************   Double Click   ************************


Private Sub Worksheet_BeforeDoubleClick(ByVal target As Range, Cancel As Boolean)
    If target.Areas.Count = 1 Then
        If target.column = GetCol("Attached Image(s) [Double Click]") And target.Row > 3 Then
            SetAttachment target:=target
        ElseIf target.column = GetCol("Characteristic Name") And target.Font.color = RGB(68, 114, 196) Then
            ExpandGroup target:=target
        End If
    End If
End Sub

Private Sub SetAttachment(target As Range)
    Dim fso As FileSystemObject
    Dim path As String
    Set fso = New FileSystemObject
    path = Replace(ThisWorkbook.path, fso.GetFileName(ThisWorkbook.path), "Attachments")
10
    If Not (fso.FolderExists(path)) Then
        Dim result As Integer
        result = MsgBox("There doesn't seem to be an 'Attachments' directory for this project" & vbCrLf & "Would you like to create one?", vbYesNo)
        If result = vbYes Then
            fso.CreateFolder (path)
            GoTo 10
        Else
            Exit Sub
        End If
    End If
    
    'After we check to see if the "Attachments" folder exists
    target.Value = ""
    
    With Application.FileDialog(msoFileDialogFilePicker)
        .InitialFileName = path
        .Title = "Select Feature Attachment(s)"
        .Show
        Dim i As Integer
        For i = 1 To .SelectedItems.Count
            Dim arr() As String
            arr = Split(.SelectedItems.Item(i), "\")
            target.Value = target.Value & arr(UBound(arr))
            'If there's more than one file, then we need to delimit it by a character that can't appear in the file name
            If i <> .SelectedItems.Count Then
                target.Value = target.Value & "|"
            End If
        Next i
    End With
    target.offset(1, 0).Select

End Sub

Private Sub ExpandGroup(target As Range)
    'Show/Hide children of multiple instance features when user double-clicks
    Dim child As Range
    Set child = target.offset(1, 0)
    Rows(child.Row).ShowDetail = Rows(child.Row).EntireRow.Hidden
    child.Activate
    
End Sub


'******************   On Change   ************************


Private Sub Worksheet_Change(ByVal target As Range)
    
    If target.Areas.Count = 1 Then
        Dim subCell As Range
        For Each subCell In target
            If IsInImmutableRange(targetCell:=subCell) Then Exit Sub
            
            On Error GoTo errmsg
            'change to Inspection Type (this should only trigger if the user changed the value manually)
            If subCell.column = GetCol("Inspection Type") Then
                On Error GoTo 20
                Application.EnableEvents = False 'prevent recursive looping
                If subCell.Value = "" Then
                    subCell.Font.color = RGB(0, 0, 0) 'revert back to black
                Else
                    subCell.Font.color = RGB(112, 48, 160) 'set purple to designate custom value
                End If
            'change to Inspection Method
            ElseIf subCell.column = GetCol("Inspection Method") Then
                On Error GoTo 20
                Application.EnableEvents = False 'prevent recursive looping
                
                Call SetInspMethodValidation(cell:=subCell) 'Reset the validation in case of copy/paste
                
                If subCell.Value = "" Then
                    subCell.offset(0, -7).Value = "" 'set Insp Type to nothing
                    subCell.offset(0, 2).Value = "" 'set Pins/Gauges to nothing
                Else
                    Dim inspType As String
                    
                    inspType = AssignInspType(subCell.Value) 'is Attribute/Variable type of Inspection Method?
                    
                    Dim minIndex As Integer
                    Dim maxIndex As Integer
                    minIndex = InStr(subCell.offset(0, -2).Value, "MIN")
                    maxIndex = InStr(subCell.offset(0, -2).Value, "MAX")
                    If inspType = "Variable" And (minIndex > 0 Or maxIndex > 0) Then
                        If (InStr(subCell.offset(0, -2).Value, "MINOR") = 0) Then
                            If Not (subCell.offset(0, -9).Font.color = RGB(112, 48, 160)) Then 'if the text is purple already, we should not prompt for mfg tol
                            
                                Dim result As Integer
                                result = MsgBox("When using an Inpsection Method of a Variable Inspection Type to check a MAX/MIN dimension" _
                                                & " it is STRONGLY recommended that you set a Mfg. Tolerance." & vbCrLf & vbCrLf _
                                                & "Set Mfg Tolernace?", vbYesNoCancel, "Variable Insp. on a Min/Max Dimension")
                                If result = vbCancel Then
                                    subCell.Value = ""
                                    GoTo 10
                                ElseIf result = vbYes Then
                                    Call LoadMfgTol(inspMethodCell:=subCell, minIndex:=minIndex, maxIndex:=maxIndex)
                                Else
                                    'User doesnt care, do nothing
                                End If
                            End If
                        End If
                    End If
                    
                    subCell.offset(0, -7).Value = inspType 'set Attribute/Variable
                    subCell.offset(0, 2).Value = SetGaugePinData(methodCell:=subCell) 'Set Gauge Pin data if applicable
                    
                End If
                subCell.offset(0, -7).Font.color = RGB(0, 0, 0) 'set Attr/Variable text to black
            ElseIf target.column = GetCol("Ltol") Or target.column = GetCol("Nominal") Or target.column = GetCol("Utol") Then
                'TODO: if these cells were manually changed, we should set the color and maybe even prompt the user to add a mfg tol note
            ElseIf target.column >= GetCol("2 DIGIT Primary Tool") And target.column <= GetCol("Secondary Head") Then
                On Error GoTo 20
                Application.EnableEvents = False
                target.Value = UCase(target.Value)
                    'TODO: check that this is not in the immutable rnage
                    'TODO: check that this is not an empty string
                
                If target.column = GetCol("Primary Control") Or target.column = GetCol("Secondary Control") Then
                    'TODO: if the user manually entered a value for the controls, we should hand-validate the entry
                    'TODO: likely should turn off events before setting this value
                    Call ValidateControl(controlCell:=target)
                    
                ElseIf target.column = GetCol("Primary Head") Or target.column = GetCol("Secondary Head") Then
                    Call ValidateHead(controlCell:=target)
                End If
                'If we made a chang to one of our TOOL Controls, we should re-evaluate the TOOL AXIS OFFSET
                Call OffsetCommentFormat(offsetRange:=target.offset(0, GetCol("TOOL AXIS OFFSET") - target.column))
                
                'Somebody changed the control, either manually typed or perhaps set with a drop-down choice
            ElseIf target.column = GetCol("Comments") Then
                Call SetCommentsValidation(cell:=subCell) 'Reset the validation in case of copy/paste
            End If
        Next subCell
    End If
20
    Application.EnableEvents = True
10
    Exit Sub
errmsg:
    MsgBox (Err.Number & vbCrLf & Err.Description)
    GoTo 20
End Sub


'************************************************************
'***************   Support Functions   **********************
'************************************************************

'***************   Inspection Methods   *********************

Private Function AssignInspType(Method As String) As String
    Dim valWB As Workbook
    Dim valSheet As Worksheet
    On Error GoTo 10
    Set valWB = Workbooks("RoutineMapDataValidations.xlsm")
    Set valSheet = valWB.Worksheets("Data Validations")
    
    Dim workingRange As Range
    Set workingRange = valSheet.Range("$E$2:$F$" & valSheet.Range("F2").End(xlDown).Row)
    Dim inspType As Variant
    inspType = Application.WorksheetFunction.VLookup(Method, workingRange, 2, False)
    AssignInspType = inspType
    
10
End Function

Private Function SetGaugePinData(methodCell As Range) As String

    'Gauge Pins method called out
    If InStr(methodCell.Value, "Gauge Pins") > 0 Then
        Dim ballNum As String
        Dim iexWS As Worksheet
        ballNum = Split(methodCell.offset(0, -3).Value, "_")(0) 'error handling here in event that it isnt a balloon number [(iv)]
        
        Set iexWS = Worksheets("IEX-Data")
        Dim workingRange As Range
        Set workingRange = iexWS.Range("A2:G" & iexWS.Range("G2").End(xlDown).Row)
        
        'Error handling in the event we can't find the balloon
        Dim units As String
        units = Application.WorksheetFunction.VLookup(ballNum, workingRange, 7, False)
        Dim featureType As String
        featureType = Application.WorksheetFunction.VLookup(ballNum, workingRange, 5, False)
        
        Dim trunc As Double
        Dim nom As Double
        Dim conv As Double
        Dim tol As Double
        Dim lTol As Double
        Dim uTol As Double
        Dim setPins As Boolean
        Dim userInput As String
        
        'What are the dimension units
        Select Case units
        Case "deg"
            GoTo 80
        Case "mm" 'only use Inch pins, so we need to convert
            conv = 25.4
        Case "in"
            conv = 1
        Case Else
            MsgBox ("Dimension does not have a recognized unit type")
            GoTo 80
        End Select
        
        'What is the tolerance range
        tol = CDbl(methodCell.offset(0, 4).Value) / conv
        nom = ((CDbl(methodCell.offset(0, -8).Value) + CDbl(methodCell.offset(0, -10).Value)) / conv) / 2
        
        
        'GDT features have a 'target' value set, but nothing for low/high values. Therefore
        'we should be handling the nominal differently by converting just that target value
        If featureType = "Geometric Tolerance" Then
            nom = CDbl(methodCell.offset(0, -9).Value) / conv
        End If
            
        If methodCell.Value = "Gauge Pins  Go" Then
            If featureType = "Geometric Tolerance" Then GoTo 80
            lTol = CDbl(methodCell.offset(0, -10).Value) / conv
            SetGaugePinData = "(" & Format(lTol, ".0000") & " FULL)"
            
        ElseIf methodCell.Value = "Gauge Pins  NoGo" Then
            If featureType = "Geometric Tolerance" Then GoTo 80
            uTol = CDbl(methodCell.offset(0, -8).Value) / conv
            SetGaugePinData = "(" & Format(uTol, ".0000") & " FULL)"
            
        ElseIf methodCell.Value = "Gauge Pins  Var.Best.Fit." Then
            uTol = nom + (tol / 2)
            lTol = nom - (tol / 2)
            userInput = InputBox("Enter gauge pin size to step by" & vbCrLf & "(Must be in Inches)", , ".0002")
            
            If featureType = "Geometric Tolerance" Then
                SetGaugePinData = "(.0000" & " through " & Format(nom, ".0000") & ")" & " by " & userInput
            Else
                SetGaugePinData = "(" & Format(lTol, ".0000") & " through " & Format(uTol, ".0000") & ")" & " by " & userInput
            End If
            
            
        ElseIf methodCell.Value = "Gauge Pins  Go/NoGo" Then
            If featureType = "Geometric Tolerance" Then GoTo FullFMT
            
        'If we donthave a MIN/MAX keyword present
            If Not (InStr(methodCell.offset(0, -2), "MAX") > 0) And Not (InStr(methodCell.offset(0, -2), "MIN") > 0) Then
                Select Case tol
                Case Is >= 0.002 'Needs 50% Truncation
                    trunc = 0.25
                    setPins = True
                Case Is > 0.001  'Needs 25% Truncation
                    trunc = 0.125
                    setPins = True
                Case Else        'No Truncation
                    setPins = False
                End Select
                
                Dim setString As String
                Dim fullString As String
                
                If setPins = True Then
                    setString = "(" & Format(nom - (tol * trunc), ".0000") & " " & Format(nom + (tol * trunc), ".0000")
                    setString = setString & " SET)"
                End If
                
                fullString = "(" & Format(nom - (tol * 0.5), ".0000") & " " & Format(nom + (tol * 0.5), ".0000")
                fullString = fullString & " FULL)"
            Else
                'otherwise it is a MIN/MAX/GDT, only use a FULL here
                'we have to switch to using the nominal cell value
                nom = CDbl(methodCell.offset(0, -9).Value) / conv
FullFMT:
                fullString = "(" & Format(nom, ".0000") & " FULL)"
            End If
            
            Dim resultString As String
            If setPins = True Then resultString = setString & " "
            SetGaugePinData = resultString & fullString
        End If
           
    'Thread Guage(s) is chosen
    ElseIf InStr(methodCell.Value, "Thread") > 0 And InStr(methodCell.Value, "Gauge") > 0 Then
        'if we are calling out a thread gauge to be used, then set this value as equal to the description most likely
        SetGaugePinData = methodCell.offset(0, -2).Value
        
    'Most Likely, Functional Gauge is chosen
    ElseIf InStr(methodCell.Value, "Gauge") > 0 Or InStr(methodCell.Value, "Inspection Fixture") > 0 Then
        Dim displayMsg As String
        Dim collectedGauges As String
        displayMsg = "Add a JPMC Gauge Number?"
        
        Do
            userInput = InputBox(displayMsg, "Enter Gauge ID")
            userInput = Trim(userInput)
            displayMsg = "Add another JPMC Gauge Number?"
            If userInput <> vbNullString And collectedGauges <> vbNullString Then
                collectedGauges = collectedGauges & ", "
            End If
            
            collectedGauges = collectedGauges & userInput
        
        Loop While userInput <> vbNullString
        
        If collectedGauges = vbNullString Then collectedGauges = "????"
        SetGaugePinData = "(JPMC " & collectedGauges & ")"
    Else
80
        SetGaugePinData = "NA"
    End If
End Function


'***************   Mfg Tolerances   *********************

'Display the mfg tol Userform
Public Sub LoadMfgTol(inspMethodCell As Range, minIndex As Integer, maxIndex As Integer)
    Load CreateMfgTolerance
    If maxIndex > 0 Then 'If this is a MAX dimension, disable the Utol Input field
        CreateMfgTolerance.UTolTextBox = inspMethodCell.offset(0, -8).Value
        CreateMfgTolerance.UTolTextBox.Enabled = False
    ElseIf minIndex > 0 Then 'If this is a MIN dimension, disable the Ltol Input field
        CreateMfgTolerance.LTolTextBox = inspMethodCell.offset(0, -10).Value
        CreateMfgTolerance.LTolTextBox.Enabled = False
    End If
    CreateMfgTolerance.Tag = inspMethodCell.offset(0, -11).Address 'Userform needs to know what cells to change
    CreateMfgTolerance.Show

End Sub

'Called by mfg Tol userform
'TODO: maybe this method can be called from a ribbon function to set a new mfg tolerance
Sub SetMfgTol(charAddress As String, inputs() As Variant)
    Dim charRange As Range
    Set charRange = Range(charAddress) 'Address of e.g. 0_008_01
    Dim i As Integer
    
    For i = 1 To 3
        Dim offsetRange As Range
        Set offsetRange = charRange.offset(0, i)
        
        'If we want to skip overriding of already mfg tol values
        'If offsetRange.Font.Color = RGB(112, 48, 160) Then GoTo continue
        
        If offsetRange.Value = "" Then offsetRange.Value = 0
        
        If (offsetRange.CommentThreaded Is Nothing) Then
            offsetRange.AddCommentThreaded ("Original Value: " & offsetRange.Value)
        Else
            offsetRange.CommentThreaded.AddReply ("Prev Value: " & offsetRange.Value)
        End If
        offsetRange.Value = inputs(i - 1)
        offsetRange.Font.color = RGB(112, 48, 160)
        
continue:
    Next i
    
    Dim commentRange As Range
    Set commentRange = charRange.offset(0, 10)
    If Not (InStr(commentRange.Value, "Mfg. Tol") > 0) Then
        commentRange.Value = commentRange.Value & "Mfg. Tol."
    End If
    
End Sub

'***************   Tool Axis Offset   *********************



'Values in the given cell should either be from the selectable drop-down list or (#XXX or DXXX) format
Sub ValidateControl(controlCell As Range)
    Dim cellInput As String
    Dim validInput As Boolean
    Dim i As Integer
    Application.EnableEvents = False
    On Error GoTo 10
    
'    controlCell.Value = UCase(controlCell.Value)
    If Len(controlCell.Value = 3) And IsNumeric(controlCell.Value) Then
        controlCell.Value = "#" & controlCell.Value
    End If
    
    For i = 1 To Len(controlCell.Value)
        If IsNumeric(Mid(controlCell.Value, i, 1)) Then
            cellInput = cellInput & "?"
        Else
            cellInput = cellInput & Mid(controlCell.Value, i, 1)
        End If
    Next i
    
    Call OpenDataValidations
    validInput = valWB.ControlIsInValidationRange(cellInput)
    
    If Not validInput Then
        controlCell.Value = ""
    End If

10
    Application.EnableEvents = True
        
End Sub

Sub ValidateHead(controlCell As Range)
    Dim headInput As String
    headInput = controlCell.Value
    Call OpenDataValidations
    
    If IsNumeric(headInput) Then
        If CInt(headInput) <= 3 And CInt(headInput) >= 1 Then
            controlCell.Value = "HD" & headInput
        Else
            GoTo 10
        End If
    ElseIf valWB.HeadIsInValidationRange(headInput) Then
        
    Else
10
        controlCell.Value = ""
    End If

End Sub

'Recalculate the 'Tool Axis Offset' Field
'We should also evaluate that both sets of columns are not just duplicates of each other
Private Sub OffsetCommentFormat(offsetRange As Range) 'TODO: add parameter here to take an input field

    offsetRange.Value = ""
    
    Dim expandedFormat As Boolean
    Dim Tpr As String
    Dim Tse As String
    Dim Cpr As String
    Dim Cse As String
    Dim Hpr As String
    Dim Hse As String
    
    Tpr = ParseToolValue(Trim(offsetRange.offset(0, 2).Value))
    Tse = ParseToolValue(Trim(offsetRange.offset(0, 5).Value))
    Cpr = offsetRange.offset(0, 3).Value
    Cse = offsetRange.offset(0, 6).Value
    Hpr = " " & offsetRange.offset(0, 4).Value
    Hse = " " & offsetRange.offset(0, 7).Value
    
    'If data is missing from the primary columns, then dont do anything
    If Tpr = vbNullString Or Cpr = vbNullString Or Trim(Hpr) = vbNullString Then
        Exit Sub
    End If
    'If all of the values in the second set are nothing, then that is fin
    If Tse = vbNullString And Cse = vbNullString And Trim(Hse) = vbNullString Then
    
    'If all of the values in the second set have something filled in then that is fine too
    ElseIf Tse <> vbNullString And Cse <> vbNullString And Trim(Hse) <> vbNullString Then
    
    Else 'Otherwise we have a partial fillout, the result should remain ""
        Exit Sub
    End If
    
    Tpr = "T" & Format(Tpr, "00")
    If Tse <> vbNullString Then Tse = "T" & Format(Tse, "00")
    
    
    'We should also just escape I guess if both sets of columns are the same
    
    
    'if the secondary column is incomplete then we should set all the secondary stuff to ""
    If Tse = vbNullString Or Cse = vbNullString Or Hse = vbNullString Then
        'if even one value is missing, set them all to nothing
        Tse = vbNullString
        Cse = vbNullString
        Hse = vbNullString
    
    ElseIf StrComp(Hpr, Hse, vbTextCompare) = 0 And StrComp(Tpr, Tse, vbTextCompare) = 0 Then
        Tse = ""
        Hpr = ""
    ElseIf StrComp(Hpr, Hse, vbTextCompare) = 0 Then
        Hpr = " "
    ElseIf Trim(Hse) <> "" Then
        expandedFormat = True
    End If
    
    If expandedFormat = False Then
        offsetRange.Value = (Tpr & GetControlDelimiter(Cpr) & Cpr & Hpr & Tse & GetControlDelimiter(Cse) & Cse & Hse)
    Else
        offsetRange.Value = (Tpr & GetControlDelimiter(Cpr) & Cpr & Hpr & " & " & Tse & GetControlDelimiter(Cse) & Cse & Hse)
    End If

End Sub


Private Function GetControlDelimiter(control As String) As String
    Select Case control
        Case "TOOL"
            GetControlDelimiter = " "
        Case "PROG"
            GetControlDelimiter = " "
        Case vbNullString
            GetControlDelimiter = ""
        Case Else
            GetControlDelimiter = ","
    End Select

End Function

Private Function ParseToolValue(tool As String) As String
    If Left(tool, 1) = "T" And Len(tool) > 1 Then
        If Right(tool, Len(tool) - 1) Then
            ParseToolValue = Right(tool, Len(tool) - 1)
        Else
            GoTo 10
        End If
    ElseIf IsNumeric(tool) Then
        ParseToolValue = tool
    Else
10
        'We can't parse this, doesn't makes sense
    End If

End Function


































